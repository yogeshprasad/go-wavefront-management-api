// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FacetsSearchRequestContainer facets search request container
//
// swagger:model FacetsSearchRequestContainer
type FacetsSearchRequestContainer struct {

	// A string against which facet results are compared.  If the facet result either CONTAINs, STARTSWITH, or is an EXACT match for this value, as specified by facetQueryMatchingMethod, then it is returned
	FacetQuery string `json:"facetQuery,omitempty"`

	// The matching method used to filter when 'facetQuery' is used. Defaults to CONTAINS.
	// Enum: [CONTAINS STARTSWITH EXACT TAGPATH]
	FacetQueryMatchingMethod string `json:"facetQueryMatchingMethod,omitempty"`

	// A list of facets (property keys) to return values from found in entities matching 'query'.  Examples are 'tags', 'creatorId', etc
	// Required: true
	Facets []string `json:"facets"`

	// The number of results to return.  Default 100, Maximum allowed: 1000
	// Maximum: 1000
	// Minimum: 1
	Limit int32 `json:"limit,omitempty"`

	// A list of queries by which to limit the search results.  Entities that match ALL queries in this list constitute a set of 'entity search results'.  All facets listed in the 'facets' search parameter of all entities within 'entity search results' are scanned to produce the search results (of facet values).
	Query []*SearchQuery `json:"query"`
}

// Validate validates this facets search request container
func (m *FacetsSearchRequestContainer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFacetQueryMatchingMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFacets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuery(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var facetsSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CONTAINS","STARTSWITH","EXACT","TAGPATH"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		facetsSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum = append(facetsSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum, v)
	}
}

const (

	// FacetsSearchRequestContainerFacetQueryMatchingMethodCONTAINS captures enum value "CONTAINS"
	FacetsSearchRequestContainerFacetQueryMatchingMethodCONTAINS string = "CONTAINS"

	// FacetsSearchRequestContainerFacetQueryMatchingMethodSTARTSWITH captures enum value "STARTSWITH"
	FacetsSearchRequestContainerFacetQueryMatchingMethodSTARTSWITH string = "STARTSWITH"

	// FacetsSearchRequestContainerFacetQueryMatchingMethodEXACT captures enum value "EXACT"
	FacetsSearchRequestContainerFacetQueryMatchingMethodEXACT string = "EXACT"

	// FacetsSearchRequestContainerFacetQueryMatchingMethodTAGPATH captures enum value "TAGPATH"
	FacetsSearchRequestContainerFacetQueryMatchingMethodTAGPATH string = "TAGPATH"
)

// prop value enum
func (m *FacetsSearchRequestContainer) validateFacetQueryMatchingMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, facetsSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FacetsSearchRequestContainer) validateFacetQueryMatchingMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.FacetQueryMatchingMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateFacetQueryMatchingMethodEnum("facetQueryMatchingMethod", "body", m.FacetQueryMatchingMethod); err != nil {
		return err
	}

	return nil
}

func (m *FacetsSearchRequestContainer) validateFacets(formats strfmt.Registry) error {

	if err := validate.Required("facets", "body", m.Facets); err != nil {
		return err
	}

	return nil
}

func (m *FacetsSearchRequestContainer) validateLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.Limit) { // not required
		return nil
	}

	if err := validate.MinimumInt("limit", "body", int64(m.Limit), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("limit", "body", int64(m.Limit), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *FacetsSearchRequestContainer) validateQuery(formats strfmt.Registry) error {
	if swag.IsZero(m.Query) { // not required
		return nil
	}

	for i := 0; i < len(m.Query); i++ {
		if swag.IsZero(m.Query[i]) { // not required
			continue
		}

		if m.Query[i] != nil {
			if err := m.Query[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("query" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("query" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this facets search request container based on the context it is used
func (m *FacetsSearchRequestContainer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateQuery(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FacetsSearchRequestContainer) contextValidateQuery(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Query); i++ {

		if m.Query[i] != nil {
			if err := m.Query[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("query" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("query" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FacetsSearchRequestContainer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FacetsSearchRequestContainer) UnmarshalBinary(b []byte) error {
	var res FacetsSearchRequestContainer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
