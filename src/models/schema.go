// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Schema schema
//
// swagger:model Schema
type Schema struct {

	// aliases
	// Unique: true
	Aliases []string `json:"aliases"`

	// doc
	Doc string `json:"doc,omitempty"`

	// element type
	ElementType *Schema `json:"elementType,omitempty"`

	// enum default
	EnumDefault string `json:"enumDefault,omitempty"`

	// enum symbols
	EnumSymbols []string `json:"enumSymbols"`

	// error
	Error bool `json:"error,omitempty"`

	// fields
	Fields []*Field `json:"fields"`

	// fixed size
	FixedSize int32 `json:"fixedSize,omitempty"`

	// full name
	FullName string `json:"fullName,omitempty"`

	// logical type
	LogicalType *LogicalType `json:"logicalType,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// namespace
	Namespace string `json:"namespace,omitempty"`

	// nullable
	Nullable bool `json:"nullable,omitempty"`

	// object props
	ObjectProps map[string]interface{} `json:"objectProps,omitempty"`

	// type
	// Enum: [RECORD ENUM ARRAY MAP UNION FIXED STRING BYTES INT LONG FLOAT DOUBLE BOOLEAN NULL]
	Type string `json:"type,omitempty"`

	// types
	Types []*Schema `json:"types"`

	// union
	Union bool `json:"union,omitempty"`

	// value type
	ValueType *Schema `json:"valueType,omitempty"`
}

// Validate validates this schema
func (m *Schema) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAliases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateElementType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFields(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogicalType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Schema) validateAliases(formats strfmt.Registry) error {
	if swag.IsZero(m.Aliases) { // not required
		return nil
	}

	if err := validate.UniqueItems("aliases", "body", m.Aliases); err != nil {
		return err
	}

	return nil
}

func (m *Schema) validateElementType(formats strfmt.Registry) error {
	if swag.IsZero(m.ElementType) { // not required
		return nil
	}

	if m.ElementType != nil {
		if err := m.ElementType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("elementType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("elementType")
			}
			return err
		}
	}

	return nil
}

func (m *Schema) validateFields(formats strfmt.Registry) error {
	if swag.IsZero(m.Fields) { // not required
		return nil
	}

	for i := 0; i < len(m.Fields); i++ {
		if swag.IsZero(m.Fields[i]) { // not required
			continue
		}

		if m.Fields[i] != nil {
			if err := m.Fields[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Schema) validateLogicalType(formats strfmt.Registry) error {
	if swag.IsZero(m.LogicalType) { // not required
		return nil
	}

	if m.LogicalType != nil {
		if err := m.LogicalType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logicalType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logicalType")
			}
			return err
		}
	}

	return nil
}

var schemaTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RECORD","ENUM","ARRAY","MAP","UNION","FIXED","STRING","BYTES","INT","LONG","FLOAT","DOUBLE","BOOLEAN","NULL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		schemaTypeTypePropEnum = append(schemaTypeTypePropEnum, v)
	}
}

const (

	// SchemaTypeRECORD captures enum value "RECORD"
	SchemaTypeRECORD string = "RECORD"

	// SchemaTypeENUM captures enum value "ENUM"
	SchemaTypeENUM string = "ENUM"

	// SchemaTypeARRAY captures enum value "ARRAY"
	SchemaTypeARRAY string = "ARRAY"

	// SchemaTypeMAP captures enum value "MAP"
	SchemaTypeMAP string = "MAP"

	// SchemaTypeUNION captures enum value "UNION"
	SchemaTypeUNION string = "UNION"

	// SchemaTypeFIXED captures enum value "FIXED"
	SchemaTypeFIXED string = "FIXED"

	// SchemaTypeSTRING captures enum value "STRING"
	SchemaTypeSTRING string = "STRING"

	// SchemaTypeBYTES captures enum value "BYTES"
	SchemaTypeBYTES string = "BYTES"

	// SchemaTypeINT captures enum value "INT"
	SchemaTypeINT string = "INT"

	// SchemaTypeLONG captures enum value "LONG"
	SchemaTypeLONG string = "LONG"

	// SchemaTypeFLOAT captures enum value "FLOAT"
	SchemaTypeFLOAT string = "FLOAT"

	// SchemaTypeDOUBLE captures enum value "DOUBLE"
	SchemaTypeDOUBLE string = "DOUBLE"

	// SchemaTypeBOOLEAN captures enum value "BOOLEAN"
	SchemaTypeBOOLEAN string = "BOOLEAN"

	// SchemaTypeNULL captures enum value "NULL"
	SchemaTypeNULL string = "NULL"
)

// prop value enum
func (m *Schema) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, schemaTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Schema) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Schema) validateTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.Types) { // not required
		return nil
	}

	for i := 0; i < len(m.Types); i++ {
		if swag.IsZero(m.Types[i]) { // not required
			continue
		}

		if m.Types[i] != nil {
			if err := m.Types[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("types" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("types" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Schema) validateValueType(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueType) { // not required
		return nil
	}

	if m.ValueType != nil {
		if err := m.ValueType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("valueType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("valueType")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this schema based on the context it is used
func (m *Schema) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateElementType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFields(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValueType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Schema) contextValidateElementType(ctx context.Context, formats strfmt.Registry) error {

	if m.ElementType != nil {
		if err := m.ElementType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("elementType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("elementType")
			}
			return err
		}
	}

	return nil
}

func (m *Schema) contextValidateFields(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Fields); i++ {

		if m.Fields[i] != nil {
			if err := m.Fields[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fields" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fields" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Schema) contextValidateLogicalType(ctx context.Context, formats strfmt.Registry) error {

	if m.LogicalType != nil {
		if err := m.LogicalType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logicalType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logicalType")
			}
			return err
		}
	}

	return nil
}

func (m *Schema) contextValidateTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Types); i++ {

		if m.Types[i] != nil {
			if err := m.Types[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("types" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("types" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Schema) contextValidateValueType(ctx context.Context, formats strfmt.Registry) error {

	if m.ValueType != nil {
		if err := m.ValueType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("valueType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("valueType")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Schema) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Schema) UnmarshalBinary(b []byte) error {
	var res Schema
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
