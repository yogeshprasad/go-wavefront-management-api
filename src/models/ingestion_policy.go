// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IngestionPolicy Api model for ingestion policy
//
// swagger:model IngestionPolicy
type IngestionPolicy struct {

	// Total number of accounts that are linked to the ingestion policy
	// Read Only: true
	AccountCount int32 `json:"accountCount,omitempty"`

	// The ingestion policy alert Id
	AlertID string `json:"alertId,omitempty"`

	// ID of the customer to which the ingestion policy belongs
	Customer string `json:"customer,omitempty"`

	// The description of the ingestion policy
	Description string `json:"description,omitempty"`

	// Total number of groups that are linked to the ingestion policy
	// Read Only: true
	GroupCount int32 `json:"groupCount,omitempty"`

	// The unique ID for the ingestion policy
	ID string `json:"id,omitempty"`

	// Whether the ingestion policy is limited
	IsLimited bool `json:"isLimited,omitempty"`

	// The account that updated this ingestion policy last time
	// Read Only: true
	LastUpdatedAccountID string `json:"lastUpdatedAccountId,omitempty"`

	// The last time when the ingestion policy is updated, in epoch milliseconds
	LastUpdatedMs int64 `json:"lastUpdatedMs,omitempty"`

	// The PPS limit of the ingestion policy
	LimitPPS int32 `json:"limitPPS,omitempty"`

	// The name of the ingestion policy
	Name string `json:"name,omitempty"`

	// A sample of the accounts assigned to this ingestion policy. Please use the Ingestion Policy facet of the Account Search API to get the full list of accounts for this policy
	// Read Only: true
	// Unique: true
	SampledAccounts []string `json:"sampledAccounts"`

	// A sample of the groups assigned to this ingestion policy. Please use the Ingestion Policy facet of the Group Search API to get the full list of groups for this policy
	// Read Only: true
	// Unique: true
	SampledGroups []*UserGroup `json:"sampledGroups"`

	// A sample of the service accounts accounts assigned to this ingestion policy. Please use the Ingestion Policy facet of the Account Search API to get the full list of service accounts for this policy
	// Read Only: true
	// Unique: true
	SampledServiceAccounts []string `json:"sampledServiceAccounts"`

	// A sample of the user accounts assigned to this ingestion policy. Please use the Ingestion Policy facet of the Account Search API to get the full list of users for this policy
	// Read Only: true
	// Unique: true
	SampledUserAccounts []string `json:"sampledUserAccounts"`

	// The scope of the ingestion policy
	// Enum: [ACCOUNT GROUP]
	Scope string `json:"scope,omitempty"`

	// Total number of service accounts that are linked to the ingestion policy
	// Read Only: true
	ServiceAccountCount int32 `json:"serviceAccountCount,omitempty"`

	// Total number of user accounts that are linked to the ingestion policy
	// Read Only: true
	UserAccountCount int32 `json:"userAccountCount,omitempty"`
}

// Validate validates this ingestion policy
func (m *IngestionPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSampledAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSampledGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSampledServiceAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSampledUserAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IngestionPolicy) validateSampledAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledAccounts) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledAccounts", "body", m.SampledAccounts); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) validateSampledGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledGroups) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledGroups", "body", m.SampledGroups); err != nil {
		return err
	}

	for i := 0; i < len(m.SampledGroups); i++ {
		if swag.IsZero(m.SampledGroups[i]) { // not required
			continue
		}

		if m.SampledGroups[i] != nil {
			if err := m.SampledGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicy) validateSampledServiceAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledServiceAccounts) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledServiceAccounts", "body", m.SampledServiceAccounts); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) validateSampledUserAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledUserAccounts) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledUserAccounts", "body", m.SampledUserAccounts); err != nil {
		return err
	}

	return nil
}

var ingestionPolicyTypeScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACCOUNT","GROUP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ingestionPolicyTypeScopePropEnum = append(ingestionPolicyTypeScopePropEnum, v)
	}
}

const (

	// IngestionPolicyScopeACCOUNT captures enum value "ACCOUNT"
	IngestionPolicyScopeACCOUNT string = "ACCOUNT"

	// IngestionPolicyScopeGROUP captures enum value "GROUP"
	IngestionPolicyScopeGROUP string = "GROUP"
)

// prop value enum
func (m *IngestionPolicy) validateScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ingestionPolicyTypeScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IngestionPolicy) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	// value enum
	if err := m.validateScopeEnum("scope", "body", m.Scope); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this ingestion policy based on the context it is used
func (m *IngestionPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccountCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroupCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdatedAccountID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledServiceAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledUserAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceAccountCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserAccountCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IngestionPolicy) contextValidateAccountCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "accountCount", "body", int32(m.AccountCount)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) contextValidateGroupCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "groupCount", "body", int32(m.GroupCount)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) contextValidateLastUpdatedAccountID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastUpdatedAccountId", "body", string(m.LastUpdatedAccountID)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) contextValidateSampledAccounts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledAccounts", "body", []string(m.SampledAccounts)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) contextValidateSampledGroups(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledGroups", "body", []*UserGroup(m.SampledGroups)); err != nil {
		return err
	}

	for i := 0; i < len(m.SampledGroups); i++ {

		if m.SampledGroups[i] != nil {
			if err := m.SampledGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicy) contextValidateSampledServiceAccounts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledServiceAccounts", "body", []string(m.SampledServiceAccounts)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) contextValidateSampledUserAccounts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledUserAccounts", "body", []string(m.SampledUserAccounts)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) contextValidateServiceAccountCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serviceAccountCount", "body", int32(m.ServiceAccountCount)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicy) contextValidateUserAccountCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "userAccountCount", "body", int32(m.UserAccountCount)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IngestionPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IngestionPolicy) UnmarshalBinary(b []byte) error {
	var res IngestionPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
