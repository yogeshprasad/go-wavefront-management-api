// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Proxy Wavefront forwarding proxy
//
// swagger:model Proxy
type Proxy struct {

	// Number of bytes of space remaining in the persistent disk queue of this proxy
	// Read Only: true
	BytesLeftForBuffer int64 `json:"bytesLeftForBuffer,omitempty"`

	// Bytes used per minute by the persistent disk queue of this proxy
	// Read Only: true
	BytesPerMinuteForBuffer int64 `json:"bytesPerMinuteForBuffer,omitempty"`

	// Proxy's rate limit
	CollectorRateLimit int64 `json:"collectorRateLimit,omitempty"`

	// When true, this proxy's rate limit is controlled remotely
	CollectorSetsRateLimit bool `json:"collectorSetsRateLimit,omitempty"`

	// customer Id
	// Read Only: true
	CustomerID string `json:"customerId,omitempty"`

	// deleted
	Deleted bool `json:"deleted,omitempty"`

	// When true, this proxy is expected to be ephemeral (possibly hosted on a short-lived container) and will be deleted after a period of inactivity (not checking in)
	// Read Only: true
	Ephemeral *bool `json:"ephemeral,omitempty"`

	// Proxy's rate limit for events
	EventsRateLimit float64 `json:"eventsRateLimit,omitempty"`

	// Proxy's histogram feature disabled
	HistoDisabled bool `json:"histoDisabled,omitempty"`

	// Proxy's rate limit for histograms
	HistogramRateLimit int64 `json:"histogramRateLimit,omitempty"`

	// Host name of the machine running the proxy
	// Read Only: true
	Hostname string `json:"hostname,omitempty"`

	// id
	ID string `json:"id,omitempty"`

	// in trash
	// Read Only: true
	InTrash *bool `json:"inTrash,omitempty"`

	// Ingestion policies associated with the proxy through user and groups
	// Read Only: true
	IngestionPolicies []*IngestionPolicy `json:"ingestionPolicies"`

	// Ingestion policy associated with the proxy
	// Read Only: true
	IngestionPolicy *IngestionPolicy `json:"ingestionPolicy,omitempty"`

	// Last time when this proxy checked in (in milliseconds since the unix epoch)
	// Read Only: true
	LastCheckInTime int64 `json:"lastCheckInTime,omitempty"`

	// last error event
	LastErrorEvent *Event `json:"lastErrorEvent,omitempty"`

	// deprecated
	// Read Only: true
	LastErrorTime int64 `json:"lastErrorTime,omitempty"`

	// deprecated
	// Read Only: true
	LastKnownError string `json:"lastKnownError,omitempty"`

	// Number of items in the persistent disk queue of this proxy
	// Read Only: true
	LocalQueueSize int64 `json:"localQueueSize,omitempty"`

	// Proxy's logs feature disabled for customer
	LogsDisabled bool `json:"logsDisabled,omitempty"`

	// Proxy name (modifiable)
	// Required: true
	Name *string `json:"name"`

	// Proxy's preprocessor rules
	PreprocessorRules string `json:"preprocessorRules,omitempty"`

	// Proxy name set by customer
	Proxyname string `json:"proxyname,omitempty"`

	// When true, attempt to shut down this proxy remotely
	Shutdown bool `json:"shutdown,omitempty"`

	// Proxy's rate limit for source tag operations
	SourceTagsRateLimit float64 `json:"sourceTagsRateLimit,omitempty"`

	// Proxy's span logs feature disabled
	SpanLogsDisabled bool `json:"spanLogsDisabled,omitempty"`

	// Proxy's rate limit for span logs
	SpanLogsRateLimit int64 `json:"spanLogsRateLimit,omitempty"`

	// Proxy's rate limit for spans
	SpanRateLimit int64 `json:"spanRateLimit,omitempty"`

	// deprecated
	// Read Only: true
	SSHAgent *bool `json:"sshAgent,omitempty"`

	// the proxy's status
	// Read Only: true
	// Enum: [ACTIVE STOPPED_UNKNOWN STOPPED_BY_SERVER]
	Status string `json:"status,omitempty"`

	// The reason why the proxy is in current status
	// Read Only: true
	StatusCause string `json:"statusCause,omitempty"`

	// Time drift of the proxy's clock compared to Wavefront servers
	// Read Only: true
	TimeDrift int64 `json:"timeDrift,omitempty"`

	// Proxy's spans feature disabled
	TraceDisabled bool `json:"traceDisabled,omitempty"`

	// When true, attempt to truncate down this proxy backlog remotely
	Truncate bool `json:"truncate,omitempty"`

	// The user associated with this proxy
	// Read Only: true
	UserID string `json:"userId,omitempty"`

	// version
	// Read Only: true
	Version string `json:"version,omitempty"`
}

// Validate validates this proxy
func (m *Proxy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIngestionPolicies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngestionPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastErrorEvent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Proxy) validateIngestionPolicies(formats strfmt.Registry) error {
	if swag.IsZero(m.IngestionPolicies) { // not required
		return nil
	}

	for i := 0; i < len(m.IngestionPolicies); i++ {
		if swag.IsZero(m.IngestionPolicies[i]) { // not required
			continue
		}

		if m.IngestionPolicies[i] != nil {
			if err := m.IngestionPolicies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ingestionPolicies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ingestionPolicies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Proxy) validateIngestionPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.IngestionPolicy) { // not required
		return nil
	}

	if m.IngestionPolicy != nil {
		if err := m.IngestionPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingestionPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ingestionPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *Proxy) validateLastErrorEvent(formats strfmt.Registry) error {
	if swag.IsZero(m.LastErrorEvent) { // not required
		return nil
	}

	if m.LastErrorEvent != nil {
		if err := m.LastErrorEvent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastErrorEvent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("lastErrorEvent")
			}
			return err
		}
	}

	return nil
}

func (m *Proxy) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var proxyTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACTIVE","STOPPED_UNKNOWN","STOPPED_BY_SERVER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		proxyTypeStatusPropEnum = append(proxyTypeStatusPropEnum, v)
	}
}

const (

	// ProxyStatusACTIVE captures enum value "ACTIVE"
	ProxyStatusACTIVE string = "ACTIVE"

	// ProxyStatusSTOPPEDUNKNOWN captures enum value "STOPPED_UNKNOWN"
	ProxyStatusSTOPPEDUNKNOWN string = "STOPPED_UNKNOWN"

	// ProxyStatusSTOPPEDBYSERVER captures enum value "STOPPED_BY_SERVER"
	ProxyStatusSTOPPEDBYSERVER string = "STOPPED_BY_SERVER"
)

// prop value enum
func (m *Proxy) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, proxyTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Proxy) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this proxy based on the context it is used
func (m *Proxy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBytesLeftForBuffer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBytesPerMinuteForBuffer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomerID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEphemeral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostname(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInTrash(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIngestionPolicies(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIngestionPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastCheckInTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastErrorEvent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastErrorTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastKnownError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalQueueSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSSHAgent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatusCause(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimeDrift(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Proxy) contextValidateBytesLeftForBuffer(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "bytesLeftForBuffer", "body", int64(m.BytesLeftForBuffer)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateBytesPerMinuteForBuffer(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "bytesPerMinuteForBuffer", "body", int64(m.BytesPerMinuteForBuffer)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateCustomerID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "customerId", "body", string(m.CustomerID)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateEphemeral(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ephemeral", "body", m.Ephemeral); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateHostname(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "hostname", "body", string(m.Hostname)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateInTrash(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "inTrash", "body", m.InTrash); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateIngestionPolicies(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ingestionPolicies", "body", []*IngestionPolicy(m.IngestionPolicies)); err != nil {
		return err
	}

	for i := 0; i < len(m.IngestionPolicies); i++ {

		if m.IngestionPolicies[i] != nil {
			if err := m.IngestionPolicies[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ingestionPolicies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ingestionPolicies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Proxy) contextValidateIngestionPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.IngestionPolicy != nil {
		if err := m.IngestionPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingestionPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ingestionPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *Proxy) contextValidateLastCheckInTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastCheckInTime", "body", int64(m.LastCheckInTime)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateLastErrorEvent(ctx context.Context, formats strfmt.Registry) error {

	if m.LastErrorEvent != nil {
		if err := m.LastErrorEvent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastErrorEvent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("lastErrorEvent")
			}
			return err
		}
	}

	return nil
}

func (m *Proxy) contextValidateLastErrorTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastErrorTime", "body", int64(m.LastErrorTime)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateLastKnownError(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastKnownError", "body", string(m.LastKnownError)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateLocalQueueSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "localQueueSize", "body", int64(m.LocalQueueSize)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateSSHAgent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sshAgent", "body", m.SSHAgent); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateStatusCause(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statusCause", "body", string(m.StatusCause)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateTimeDrift(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "timeDrift", "body", int64(m.TimeDrift)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "userId", "body", string(m.UserID)); err != nil {
		return err
	}

	return nil
}

func (m *Proxy) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version", "body", string(m.Version)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Proxy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Proxy) UnmarshalBinary(b []byte) error {
	var res Proxy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
