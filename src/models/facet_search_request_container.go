// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FacetSearchRequestContainer facet search request container
//
// swagger:model FacetSearchRequestContainer
type FacetSearchRequestContainer struct {

	// A string against which facet results are compared.  If the facet result CONTAINs, STARTSWITH, or is an EXACT match for this value, as specified by facetQueryMatchingMethod, then it is returned.
	FacetQuery string `json:"facetQuery,omitempty"`

	// The matching method used to filter when 'facetQuery' is used. Defaults to CONTAINS.
	// Enum: [CONTAINS STARTSWITH EXACT TAGPATH]
	FacetQueryMatchingMethod string `json:"facetQueryMatchingMethod,omitempty"`

	// The number of results to return.  Default: 100, Maximum allowed: 1000
	// Maximum: 1000
	// Minimum: 1
	Limit int32 `json:"limit,omitempty"`

	// The number of results to skip before returning values.  Default: 0
	Offset int32 `json:"offset,omitempty"`

	// A list of queries by which to limit the search results.  Entities that match ALL queries in the list are returned
	Query []*SearchQuery `json:"query"`
}

// Validate validates this facet search request container
func (m *FacetSearchRequestContainer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFacetQueryMatchingMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuery(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var facetSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CONTAINS","STARTSWITH","EXACT","TAGPATH"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		facetSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum = append(facetSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum, v)
	}
}

const (

	// FacetSearchRequestContainerFacetQueryMatchingMethodCONTAINS captures enum value "CONTAINS"
	FacetSearchRequestContainerFacetQueryMatchingMethodCONTAINS string = "CONTAINS"

	// FacetSearchRequestContainerFacetQueryMatchingMethodSTARTSWITH captures enum value "STARTSWITH"
	FacetSearchRequestContainerFacetQueryMatchingMethodSTARTSWITH string = "STARTSWITH"

	// FacetSearchRequestContainerFacetQueryMatchingMethodEXACT captures enum value "EXACT"
	FacetSearchRequestContainerFacetQueryMatchingMethodEXACT string = "EXACT"

	// FacetSearchRequestContainerFacetQueryMatchingMethodTAGPATH captures enum value "TAGPATH"
	FacetSearchRequestContainerFacetQueryMatchingMethodTAGPATH string = "TAGPATH"
)

// prop value enum
func (m *FacetSearchRequestContainer) validateFacetQueryMatchingMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, facetSearchRequestContainerTypeFacetQueryMatchingMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FacetSearchRequestContainer) validateFacetQueryMatchingMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.FacetQueryMatchingMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateFacetQueryMatchingMethodEnum("facetQueryMatchingMethod", "body", m.FacetQueryMatchingMethod); err != nil {
		return err
	}

	return nil
}

func (m *FacetSearchRequestContainer) validateLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.Limit) { // not required
		return nil
	}

	if err := validate.MinimumInt("limit", "body", int64(m.Limit), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("limit", "body", int64(m.Limit), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *FacetSearchRequestContainer) validateQuery(formats strfmt.Registry) error {
	if swag.IsZero(m.Query) { // not required
		return nil
	}

	for i := 0; i < len(m.Query); i++ {
		if swag.IsZero(m.Query[i]) { // not required
			continue
		}

		if m.Query[i] != nil {
			if err := m.Query[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("query" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("query" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this facet search request container based on the context it is used
func (m *FacetSearchRequestContainer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateQuery(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FacetSearchRequestContainer) contextValidateQuery(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Query); i++ {

		if m.Query[i] != nil {
			if err := m.Query[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("query" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("query" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FacetSearchRequestContainer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FacetSearchRequestContainer) UnmarshalBinary(b []byte) error {
	var res FacetSearchRequestContainer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
