// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ChartSettings Representation of the settings of a Wavefront chart
//
// swagger:model ChartSettings
type ChartSettings struct {

	// deprecated
	AutoColumnTags bool `json:"autoColumnTags,omitempty"`

	// Default color that will be used in any chart rendering. Values should be in "rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;)" format
	ChartDefaultColor string `json:"chartDefaultColor,omitempty"`

	// deprecated
	ColumnTags string `json:"columnTags,omitempty"`

	// For the tabular view, a list of point tags to display when using the "custom" tag display mode
	CustomTags []string `json:"customTags"`

	// For the tabular view, to select column for default sort
	DefaultSortColumn string `json:"defaultSortColumn,omitempty"`

	// Threshold (in seconds) for time delta between consecutive points in a series above which a dotted line will replace a solid line in line plots.  Default: 60s
	ExpectedDataSpacing int64 `json:"expectedDataSpacing,omitempty"`

	// For a chart with a fixed legend, a list of statistics to display in the legend
	FixedLegendDisplayStats []string `json:"fixedLegendDisplayStats"`

	// Whether to enable a fixed tabular legend adjacent to the chart
	FixedLegendEnabled bool `json:"fixedLegendEnabled,omitempty"`

	// Statistic to use for determining whether a series is displayed on the fixed legend
	// Enum: [CURRENT MEAN MEDIAN SUM MIN MAX COUNT]
	FixedLegendFilterField string `json:"fixedLegendFilterField,omitempty"`

	// Number of series to include in the fixed legend
	FixedLegendFilterLimit int32 `json:"fixedLegendFilterLimit,omitempty"`

	// Whether to display "Top"- or "Bottom"-ranked series in the fixed legend
	// Enum: [TOP BOTTOM]
	FixedLegendFilterSort string `json:"fixedLegendFilterSort,omitempty"`

	// deprecated
	FixedLegendHideLabel bool `json:"fixedLegendHideLabel,omitempty"`

	// Where the fixed legend should be displayed with respect to the chart
	// Enum: [RIGHT TOP LEFT BOTTOM]
	FixedLegendPosition string `json:"fixedLegendPosition,omitempty"`

	// Whether to display Metric Name fixed legend
	FixedLegendShowMetricName bool `json:"fixedLegendShowMetricName,omitempty"`

	// Whether to display Source Name fixed legend
	FixedLegendShowSourceName bool `json:"fixedLegendShowSourceName,omitempty"`

	// If true, the legend uses non-summarized stats instead of summarized
	FixedLegendUseRawStats bool `json:"fixedLegendUseRawStats,omitempty"`

	// For the tabular view, whether to group multi metrics into a single row by a common source.  If false, each metric for each source is displayed in its own row.  If true, multiple metrics for the same host will be displayed as different columns in the same row
	GroupBySource bool `json:"groupBySource,omitempty"`

	// Whether to disable the display of the floating legend (but reenable it when the ctrl-key is pressed)
	InvertDynamicLegendHoverControl bool `json:"invertDynamicLegendHoverControl,omitempty"`

	// Plot interpolation type.  linear is default
	// Enum: [linear step-before step-after basis cardinal monotone]
	LineType string `json:"lineType,omitempty"`

	// Max value of Y-axis.  Set to null or leave blank for auto
	Max float64 `json:"max,omitempty"`

	// Min value of Y-axis.  Set to null or leave blank for auto
	Min float64 `json:"min,omitempty"`

	// For the tabular view, how many point tags to display
	NumTags int32 `json:"numTags,omitempty"`

	// The Markdown content for a Markdown display, in plain text.  Use this field instead of `markdownContent`.
	PlainMarkdownContent string `json:"plainMarkdownContent,omitempty"`

	// For the tabular view, whether to display sources.  Default: true
	ShowHosts bool `json:"showHosts,omitempty"`

	// For the tabular view, whether to display labels.  Default: true
	ShowLabels bool `json:"showLabels,omitempty"`

	// For the tabular view, whether to display raw values.  Default: false
	ShowRawValues bool `json:"showRawValues,omitempty"`

	// For the tabular view, whether to display value column.  Default: true
	ShowValueColumn bool `json:"showValueColumn,omitempty"`

	// For the tabular view, whether to display display values in descending order.  Default: false
	SortValuesDescending bool `json:"sortValuesDescending,omitempty"`

	// For the single stat view, the decimal precision of the displayed number
	SparklineDecimalPrecision int32 `json:"sparklineDecimalPrecision,omitempty"`

	// For the single stat view, the color of the displayed text (when not dynamically determined). Values should be in "rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;)" format
	SparklineDisplayColor string `json:"sparklineDisplayColor,omitempty"`

	// For the single stat view, the font size of the displayed text, in percent
	SparklineDisplayFontSize string `json:"sparklineDisplayFontSize,omitempty"`

	// For the single stat view, the horizontal position of the displayed text
	// Enum: [MIDDLE LEFT RIGHT]
	SparklineDisplayHorizontalPosition string `json:"sparklineDisplayHorizontalPosition,omitempty"`

	// For the single stat view, a string to append to the displayed text
	SparklineDisplayPostfix string `json:"sparklineDisplayPostfix,omitempty"`

	// For the single stat view, a string to add before the displayed text
	SparklineDisplayPrefix string `json:"sparklineDisplayPrefix,omitempty"`

	// For the single stat view, whether to display the name of the query or the value of query
	// Enum: [VALUE LABEL]
	SparklineDisplayValueType string `json:"sparklineDisplayValueType,omitempty"`

	// deprecated
	SparklineDisplayVerticalPosition string `json:"sparklineDisplayVerticalPosition,omitempty"`

	// For the single stat view, the color of the background fill. Values should be in "rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;)" format
	SparklineFillColor string `json:"sparklineFillColor,omitempty"`

	// For the single stat view, the color of the line. Values should be in "rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;)" format
	SparklineLineColor string `json:"sparklineLineColor,omitempty"`

	// For the single stat view, a misleadingly named property.  This determines whether the sparkline of the statistic is displayed in the chart BACKGROUND, BOTTOM, or NONE
	// Enum: [BACKGROUND BOTTOM NONE]
	SparklineSize string `json:"sparklineSize,omitempty"`

	// For the single stat view, whether to apply dynamic color settings to the displayed TEXT or BACKGROUND
	// Enum: [TEXT BACKGROUND]
	SparklineValueColorMapApplyTo string `json:"sparklineValueColorMapApplyTo,omitempty"`

	// For the single stat view, a list of colors that differing query values map to.  Must contain one more element than sparklineValueColorMapValuesV2. Values should be in "rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;)" format
	SparklineValueColorMapColors []string `json:"sparklineValueColorMapColors"`

	// deprecated
	SparklineValueColorMapValues []int64 `json:"sparklineValueColorMapValues"`

	// For the single stat view, a list of boundaries for mapping different query values to colors.  Must contain one less element than sparklineValueColorMapColors
	SparklineValueColorMapValuesV2 []float32 `json:"sparklineValueColorMapValuesV2"`

	// For the single stat view, a list of display text values that different query values map to.  Must contain one more element than sparklineValueTextMapThresholds
	SparklineValueTextMapText []string `json:"sparklineValueTextMapText"`

	// For the single stat view, a list of threshold boundaries for mapping different query values to display text. Must contain one less element than sparklineValueTextMapText
	SparklineValueTextMapThresholds []float32 `json:"sparklineValueTextMapThresholds"`

	// Type of stacked chart (applicable only if chart type is stacked).  zero (default) means stacked from y=0.  expand means Normalized from 0 to 1.  wiggle means Minimize weighted changes. silhouette means to Center the Stream
	// Enum: [zero expand wiggle silhouette bars]
	StackType string `json:"stackType,omitempty"`

	// For the tabular view, which mode to use to determine which point tags to display
	// Enum: [all top custom]
	TagMode string `json:"tagMode,omitempty"`

	// For x-y scatterplots, whether to color more recent points as darker than older points. Default: false
	TimeBasedColoring bool `json:"timeBasedColoring,omitempty"`

	// Chart Type.  'line' refers to the Line Plot, 'scatter' to the Point Plot, 'stacked-area' to the Stacked Area plot, 'table' to the Tabular View, 'scatterploy-xy' to Scatter Plot, 'markdown-widget' to the Markdown display, and 'sparkline' to the Single Stat view
	// Required: true
	// Enum: [line scatterplot stacked-area stacked-column table scatterplot-xy markdown-widget sparkline globe nodemap top-k status-list histogram heatmap gauge pie]
	Type *string `json:"type"`

	// Width, in minutes, of the time window to use for "last" windowing
	WindowSize int64 `json:"windowSize,omitempty"`

	// For the tabular view, whether to use the full time window for the query or the last X minutes
	// Enum: [full last]
	Windowing string `json:"windowing,omitempty"`

	// For x-y scatterplots, max value for X-axis.  Set null for auto
	Xmax float64 `json:"xmax,omitempty"`

	// For x-y scatterplots, min value for X-axis.  Set null for auto
	Xmin float64 `json:"xmin,omitempty"`

	// Default: false. Whether to scale numerical magnitude labels for left Y-axis by 1024 in the IEC/Binary manner (instead of by 1000 like SI)
	Y0ScaleSIBy1024 bool `json:"y0ScaleSIBy1024,omitempty"`

	// Default: false. Whether to automatically adjust magnitude labels and units for the left Y-axis to favor smaller magnitudes and larger units
	Y0UnitAutoscaling bool `json:"y0UnitAutoscaling,omitempty"`

	// For plots with multiple Y-axes, max value for right-side Y-axis.  Set null for auto
	Y1Max float64 `json:"y1Max,omitempty"`

	// For plots with multiple Y-axes, min value for right-side Y-axis.  Set null for auto
	Y1Min float64 `json:"y1Min,omitempty"`

	// Default: false. Whether to scale numerical magnitude labels for right Y-axis by 1024 in the IEC/Binary manner (instead of by 1000 like SI)
	Y1ScaleSIBy1024 bool `json:"y1ScaleSIBy1024,omitempty"`

	// Default: false. Whether to automatically adjust magnitude labels and units for the right Y-axis to favor smaller magnitudes and larger units
	Y1UnitAutoscaling bool `json:"y1UnitAutoscaling,omitempty"`

	// For plots with multiple Y-axes, units for right-side Y-axis
	Y1Units string `json:"y1Units,omitempty"`

	// For x-y scatterplots, max value for Y-axis.  Set null for auto
	Ymax float64 `json:"ymax,omitempty"`

	// For x-y scatterplots, min value for Y-axis.  Set null for auto
	Ymin float64 `json:"ymin,omitempty"`
}

// Validate validates this chart settings
func (m *ChartSettings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFixedLegendFilterField(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFixedLegendFilterSort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFixedLegendPosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLineType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSparklineDisplayHorizontalPosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSparklineDisplayValueType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSparklineSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSparklineValueColorMapApplyTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStackType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTagMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWindowing(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var chartSettingsTypeFixedLegendFilterFieldPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CURRENT","MEAN","MEDIAN","SUM","MIN","MAX","COUNT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeFixedLegendFilterFieldPropEnum = append(chartSettingsTypeFixedLegendFilterFieldPropEnum, v)
	}
}

const (

	// ChartSettingsFixedLegendFilterFieldCURRENT captures enum value "CURRENT"
	ChartSettingsFixedLegendFilterFieldCURRENT string = "CURRENT"

	// ChartSettingsFixedLegendFilterFieldMEAN captures enum value "MEAN"
	ChartSettingsFixedLegendFilterFieldMEAN string = "MEAN"

	// ChartSettingsFixedLegendFilterFieldMEDIAN captures enum value "MEDIAN"
	ChartSettingsFixedLegendFilterFieldMEDIAN string = "MEDIAN"

	// ChartSettingsFixedLegendFilterFieldSUM captures enum value "SUM"
	ChartSettingsFixedLegendFilterFieldSUM string = "SUM"

	// ChartSettingsFixedLegendFilterFieldMIN captures enum value "MIN"
	ChartSettingsFixedLegendFilterFieldMIN string = "MIN"

	// ChartSettingsFixedLegendFilterFieldMAX captures enum value "MAX"
	ChartSettingsFixedLegendFilterFieldMAX string = "MAX"

	// ChartSettingsFixedLegendFilterFieldCOUNT captures enum value "COUNT"
	ChartSettingsFixedLegendFilterFieldCOUNT string = "COUNT"
)

// prop value enum
func (m *ChartSettings) validateFixedLegendFilterFieldEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeFixedLegendFilterFieldPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateFixedLegendFilterField(formats strfmt.Registry) error {
	if swag.IsZero(m.FixedLegendFilterField) { // not required
		return nil
	}

	// value enum
	if err := m.validateFixedLegendFilterFieldEnum("fixedLegendFilterField", "body", m.FixedLegendFilterField); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeFixedLegendFilterSortPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TOP","BOTTOM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeFixedLegendFilterSortPropEnum = append(chartSettingsTypeFixedLegendFilterSortPropEnum, v)
	}
}

const (

	// ChartSettingsFixedLegendFilterSortTOP captures enum value "TOP"
	ChartSettingsFixedLegendFilterSortTOP string = "TOP"

	// ChartSettingsFixedLegendFilterSortBOTTOM captures enum value "BOTTOM"
	ChartSettingsFixedLegendFilterSortBOTTOM string = "BOTTOM"
)

// prop value enum
func (m *ChartSettings) validateFixedLegendFilterSortEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeFixedLegendFilterSortPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateFixedLegendFilterSort(formats strfmt.Registry) error {
	if swag.IsZero(m.FixedLegendFilterSort) { // not required
		return nil
	}

	// value enum
	if err := m.validateFixedLegendFilterSortEnum("fixedLegendFilterSort", "body", m.FixedLegendFilterSort); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeFixedLegendPositionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RIGHT","TOP","LEFT","BOTTOM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeFixedLegendPositionPropEnum = append(chartSettingsTypeFixedLegendPositionPropEnum, v)
	}
}

const (

	// ChartSettingsFixedLegendPositionRIGHT captures enum value "RIGHT"
	ChartSettingsFixedLegendPositionRIGHT string = "RIGHT"

	// ChartSettingsFixedLegendPositionTOP captures enum value "TOP"
	ChartSettingsFixedLegendPositionTOP string = "TOP"

	// ChartSettingsFixedLegendPositionLEFT captures enum value "LEFT"
	ChartSettingsFixedLegendPositionLEFT string = "LEFT"

	// ChartSettingsFixedLegendPositionBOTTOM captures enum value "BOTTOM"
	ChartSettingsFixedLegendPositionBOTTOM string = "BOTTOM"
)

// prop value enum
func (m *ChartSettings) validateFixedLegendPositionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeFixedLegendPositionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateFixedLegendPosition(formats strfmt.Registry) error {
	if swag.IsZero(m.FixedLegendPosition) { // not required
		return nil
	}

	// value enum
	if err := m.validateFixedLegendPositionEnum("fixedLegendPosition", "body", m.FixedLegendPosition); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeLineTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["linear","step-before","step-after","basis","cardinal","monotone"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeLineTypePropEnum = append(chartSettingsTypeLineTypePropEnum, v)
	}
}

const (

	// ChartSettingsLineTypeLinear captures enum value "linear"
	ChartSettingsLineTypeLinear string = "linear"

	// ChartSettingsLineTypeStepDashBefore captures enum value "step-before"
	ChartSettingsLineTypeStepDashBefore string = "step-before"

	// ChartSettingsLineTypeStepDashAfter captures enum value "step-after"
	ChartSettingsLineTypeStepDashAfter string = "step-after"

	// ChartSettingsLineTypeBasis captures enum value "basis"
	ChartSettingsLineTypeBasis string = "basis"

	// ChartSettingsLineTypeCardinal captures enum value "cardinal"
	ChartSettingsLineTypeCardinal string = "cardinal"

	// ChartSettingsLineTypeMonotone captures enum value "monotone"
	ChartSettingsLineTypeMonotone string = "monotone"
)

// prop value enum
func (m *ChartSettings) validateLineTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeLineTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateLineType(formats strfmt.Registry) error {
	if swag.IsZero(m.LineType) { // not required
		return nil
	}

	// value enum
	if err := m.validateLineTypeEnum("lineType", "body", m.LineType); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeSparklineDisplayHorizontalPositionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MIDDLE","LEFT","RIGHT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeSparklineDisplayHorizontalPositionPropEnum = append(chartSettingsTypeSparklineDisplayHorizontalPositionPropEnum, v)
	}
}

const (

	// ChartSettingsSparklineDisplayHorizontalPositionMIDDLE captures enum value "MIDDLE"
	ChartSettingsSparklineDisplayHorizontalPositionMIDDLE string = "MIDDLE"

	// ChartSettingsSparklineDisplayHorizontalPositionLEFT captures enum value "LEFT"
	ChartSettingsSparklineDisplayHorizontalPositionLEFT string = "LEFT"

	// ChartSettingsSparklineDisplayHorizontalPositionRIGHT captures enum value "RIGHT"
	ChartSettingsSparklineDisplayHorizontalPositionRIGHT string = "RIGHT"
)

// prop value enum
func (m *ChartSettings) validateSparklineDisplayHorizontalPositionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeSparklineDisplayHorizontalPositionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateSparklineDisplayHorizontalPosition(formats strfmt.Registry) error {
	if swag.IsZero(m.SparklineDisplayHorizontalPosition) { // not required
		return nil
	}

	// value enum
	if err := m.validateSparklineDisplayHorizontalPositionEnum("sparklineDisplayHorizontalPosition", "body", m.SparklineDisplayHorizontalPosition); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeSparklineDisplayValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["VALUE","LABEL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeSparklineDisplayValueTypePropEnum = append(chartSettingsTypeSparklineDisplayValueTypePropEnum, v)
	}
}

const (

	// ChartSettingsSparklineDisplayValueTypeVALUE captures enum value "VALUE"
	ChartSettingsSparklineDisplayValueTypeVALUE string = "VALUE"

	// ChartSettingsSparklineDisplayValueTypeLABEL captures enum value "LABEL"
	ChartSettingsSparklineDisplayValueTypeLABEL string = "LABEL"
)

// prop value enum
func (m *ChartSettings) validateSparklineDisplayValueTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeSparklineDisplayValueTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateSparklineDisplayValueType(formats strfmt.Registry) error {
	if swag.IsZero(m.SparklineDisplayValueType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSparklineDisplayValueTypeEnum("sparklineDisplayValueType", "body", m.SparklineDisplayValueType); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeSparklineSizePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BACKGROUND","BOTTOM","NONE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeSparklineSizePropEnum = append(chartSettingsTypeSparklineSizePropEnum, v)
	}
}

const (

	// ChartSettingsSparklineSizeBACKGROUND captures enum value "BACKGROUND"
	ChartSettingsSparklineSizeBACKGROUND string = "BACKGROUND"

	// ChartSettingsSparklineSizeBOTTOM captures enum value "BOTTOM"
	ChartSettingsSparklineSizeBOTTOM string = "BOTTOM"

	// ChartSettingsSparklineSizeNONE captures enum value "NONE"
	ChartSettingsSparklineSizeNONE string = "NONE"
)

// prop value enum
func (m *ChartSettings) validateSparklineSizeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeSparklineSizePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateSparklineSize(formats strfmt.Registry) error {
	if swag.IsZero(m.SparklineSize) { // not required
		return nil
	}

	// value enum
	if err := m.validateSparklineSizeEnum("sparklineSize", "body", m.SparklineSize); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeSparklineValueColorMapApplyToPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TEXT","BACKGROUND"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeSparklineValueColorMapApplyToPropEnum = append(chartSettingsTypeSparklineValueColorMapApplyToPropEnum, v)
	}
}

const (

	// ChartSettingsSparklineValueColorMapApplyToTEXT captures enum value "TEXT"
	ChartSettingsSparklineValueColorMapApplyToTEXT string = "TEXT"

	// ChartSettingsSparklineValueColorMapApplyToBACKGROUND captures enum value "BACKGROUND"
	ChartSettingsSparklineValueColorMapApplyToBACKGROUND string = "BACKGROUND"
)

// prop value enum
func (m *ChartSettings) validateSparklineValueColorMapApplyToEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeSparklineValueColorMapApplyToPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateSparklineValueColorMapApplyTo(formats strfmt.Registry) error {
	if swag.IsZero(m.SparklineValueColorMapApplyTo) { // not required
		return nil
	}

	// value enum
	if err := m.validateSparklineValueColorMapApplyToEnum("sparklineValueColorMapApplyTo", "body", m.SparklineValueColorMapApplyTo); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeStackTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["zero","expand","wiggle","silhouette","bars"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeStackTypePropEnum = append(chartSettingsTypeStackTypePropEnum, v)
	}
}

const (

	// ChartSettingsStackTypeZero captures enum value "zero"
	ChartSettingsStackTypeZero string = "zero"

	// ChartSettingsStackTypeExpand captures enum value "expand"
	ChartSettingsStackTypeExpand string = "expand"

	// ChartSettingsStackTypeWiggle captures enum value "wiggle"
	ChartSettingsStackTypeWiggle string = "wiggle"

	// ChartSettingsStackTypeSilhouette captures enum value "silhouette"
	ChartSettingsStackTypeSilhouette string = "silhouette"

	// ChartSettingsStackTypeBars captures enum value "bars"
	ChartSettingsStackTypeBars string = "bars"
)

// prop value enum
func (m *ChartSettings) validateStackTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeStackTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateStackType(formats strfmt.Registry) error {
	if swag.IsZero(m.StackType) { // not required
		return nil
	}

	// value enum
	if err := m.validateStackTypeEnum("stackType", "body", m.StackType); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeTagModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","top","custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeTagModePropEnum = append(chartSettingsTypeTagModePropEnum, v)
	}
}

const (

	// ChartSettingsTagModeAll captures enum value "all"
	ChartSettingsTagModeAll string = "all"

	// ChartSettingsTagModeTop captures enum value "top"
	ChartSettingsTagModeTop string = "top"

	// ChartSettingsTagModeCustom captures enum value "custom"
	ChartSettingsTagModeCustom string = "custom"
)

// prop value enum
func (m *ChartSettings) validateTagModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeTagModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateTagMode(formats strfmt.Registry) error {
	if swag.IsZero(m.TagMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateTagModeEnum("tagMode", "body", m.TagMode); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["line","scatterplot","stacked-area","stacked-column","table","scatterplot-xy","markdown-widget","sparkline","globe","nodemap","top-k","status-list","histogram","heatmap","gauge","pie"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeTypePropEnum = append(chartSettingsTypeTypePropEnum, v)
	}
}

const (

	// ChartSettingsTypeLine captures enum value "line"
	ChartSettingsTypeLine string = "line"

	// ChartSettingsTypeScatterplot captures enum value "scatterplot"
	ChartSettingsTypeScatterplot string = "scatterplot"

	// ChartSettingsTypeStackedDashArea captures enum value "stacked-area"
	ChartSettingsTypeStackedDashArea string = "stacked-area"

	// ChartSettingsTypeStackedDashColumn captures enum value "stacked-column"
	ChartSettingsTypeStackedDashColumn string = "stacked-column"

	// ChartSettingsTypeTable captures enum value "table"
	ChartSettingsTypeTable string = "table"

	// ChartSettingsTypeScatterplotDashXy captures enum value "scatterplot-xy"
	ChartSettingsTypeScatterplotDashXy string = "scatterplot-xy"

	// ChartSettingsTypeMarkdownDashWidget captures enum value "markdown-widget"
	ChartSettingsTypeMarkdownDashWidget string = "markdown-widget"

	// ChartSettingsTypeSparkline captures enum value "sparkline"
	ChartSettingsTypeSparkline string = "sparkline"

	// ChartSettingsTypeGlobe captures enum value "globe"
	ChartSettingsTypeGlobe string = "globe"

	// ChartSettingsTypeNodemap captures enum value "nodemap"
	ChartSettingsTypeNodemap string = "nodemap"

	// ChartSettingsTypeTopDashk captures enum value "top-k"
	ChartSettingsTypeTopDashk string = "top-k"

	// ChartSettingsTypeStatusDashList captures enum value "status-list"
	ChartSettingsTypeStatusDashList string = "status-list"

	// ChartSettingsTypeHistogram captures enum value "histogram"
	ChartSettingsTypeHistogram string = "histogram"

	// ChartSettingsTypeHeatmap captures enum value "heatmap"
	ChartSettingsTypeHeatmap string = "heatmap"

	// ChartSettingsTypeGauge captures enum value "gauge"
	ChartSettingsTypeGauge string = "gauge"

	// ChartSettingsTypePie captures enum value "pie"
	ChartSettingsTypePie string = "pie"
)

// prop value enum
func (m *ChartSettings) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

var chartSettingsTypeWindowingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["full","last"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		chartSettingsTypeWindowingPropEnum = append(chartSettingsTypeWindowingPropEnum, v)
	}
}

const (

	// ChartSettingsWindowingFull captures enum value "full"
	ChartSettingsWindowingFull string = "full"

	// ChartSettingsWindowingLast captures enum value "last"
	ChartSettingsWindowingLast string = "last"
)

// prop value enum
func (m *ChartSettings) validateWindowingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, chartSettingsTypeWindowingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChartSettings) validateWindowing(formats strfmt.Registry) error {
	if swag.IsZero(m.Windowing) { // not required
		return nil
	}

	// value enum
	if err := m.validateWindowingEnum("windowing", "body", m.Windowing); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this chart settings based on context it is used
func (m *ChartSettings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ChartSettings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ChartSettings) UnmarshalBinary(b []byte) error {
	var res ChartSettings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
