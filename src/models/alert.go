// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Alert Wavefront Alert
//
// swagger:model Alert
type Alert struct {

	// acl
	// Read Only: true
	ACL *AccessControlListSimple `json:"acl,omitempty"`

	// The names of the active maintenance windows that are affecting this alert
	// Read Only: true
	ActiveMaintenanceWindows []string `json:"activeMaintenanceWindows"`

	// User-supplied additional explanatory information for this alert.  Useful for linking runbooks, mitigations,, etc
	AdditionalInformation string `json:"additionalInformation,omitempty"`

	// The base of alert chart. A linear chart will have base as 1. A logarithmic chart will have the other base value.The value should be an integer and should greater than or equal to 1.
	AlertChartBase int32 `json:"alertChartBase,omitempty"`

	// The description of alert chart. Different from alert additional info, this is used to describe the characteristics of the chart.
	AlertChartDescription string `json:"alertChartDescription,omitempty"`

	// The y-axis unit of Alert chart.
	AlertChartUnits string `json:"alertChartUnits,omitempty"`

	// A list of queries represent multiple queries in alert. It must contains at least one query with AlertSourceType as CONDITION.
	AlertSources []*AlertSource `json:"alertSources"`

	// User-supplied dashboard and parameters to create dashboard links. Parameters must be specified as constants or variables. Constant parameters currently only supported
	AlertTriageDashboards []*AlertDashboard `json:"alertTriageDashboards"`

	// Alert type.
	// Enum: [CLASSIC THRESHOLD]
	AlertType string `json:"alertType,omitempty"`

	// alerts last day
	// Read Only: true
	AlertsLastDay int32 `json:"alertsLastDay,omitempty"`

	// alerts last month
	// Read Only: true
	AlertsLastMonth int32 `json:"alertsLastMonth,omitempty"`

	// alerts last week
	// Read Only: true
	AlertsLastWeek int32 `json:"alertsLastWeek,omitempty"`

	// Lists the applications from the failingHostLabelPair of the alert.
	// Read Only: true
	Application []string `json:"application"`

	// Additional chart settings for the alert (e.g. pie chart has its chart settings in this section).
	ChartAttributes JSONNode `json:"chartAttributes,omitempty"`

	// The old chart settings for the alert (e.g. chart type, chart range etc.).
	ChartSettings *ChartSettings `json:"chartSettings,omitempty"`

	// A Wavefront query that is evaluated at regular intervals (default 1m).  The alert fires and notifications are triggered when a data series matching this query evaluates to a non-zero value for a set number of consecutive minutes
	// Required: true
	Condition *string `json:"condition"`

	// Whether the condition query was created using the Query Builder.  Default false
	ConditionQBEnabled bool `json:"conditionQBEnabled,omitempty"`

	// The special serialization of the Query Builder that corresponds to the condition query.  Applicable only when conditionQBEnabled is true
	ConditionQBSerialization string `json:"conditionQBSerialization,omitempty"`

	// condition query type
	// Enum: [WQL PROMQL HYBRID]
	ConditionQueryType string `json:"conditionQueryType,omitempty"`

	// Multi - alert conditions.
	Conditions map[string]string `json:"conditions,omitempty"`

	// create user Id
	// Read Only: true
	CreateUserID string `json:"createUserId,omitempty"`

	// When this alert was created, in epoch millis
	// Read Only: true
	Created int64 `json:"created,omitempty"`

	// created epoch millis
	// Read Only: true
	CreatedEpochMillis int64 `json:"createdEpochMillis,omitempty"`

	// creator Id
	// Read Only: true
	CreatorID string `json:"creatorId,omitempty"`

	// deleted
	// Read Only: true
	Deleted *bool `json:"deleted,omitempty"`

	// A second query whose results are displayed in the alert user interface instead of the condition query. This field is often used to display a version of the condition query with Boolean operators removed so that numerical values are plotted
	DisplayExpression string `json:"displayExpression,omitempty"`

	// Whether the display expression query was created using the Query Builder. Default false
	DisplayExpressionQBEnabled bool `json:"displayExpressionQBEnabled,omitempty"`

	// The special serialization of the Query Builder that corresponds to the display expression query.  Applicable only when displayExpressionQBEnabled is true
	DisplayExpressionQBSerialization string `json:"displayExpressionQBSerialization,omitempty"`

	// display expression query type
	// Enum: [WQL PROMQL HYBRID]
	DisplayExpressionQueryType string `json:"displayExpressionQueryType,omitempty"`

	// enable p d incident by series
	EnablePDIncidentBySeries bool `json:"enablePDIncidentBySeries,omitempty"`

	// Whether to alert on the real-time ingestion stream (may be noisy due to late data)
	EvaluateRealtimeData bool `json:"evaluateRealtimeData,omitempty"`

	// event
	Event *Event `json:"event,omitempty"`

	// List of links to tracing applications that caused a failing series
	// Read Only: true
	// Unique: true
	FailingHostLabelPairLinks []string `json:"failingHostLabelPairLinks"`

	// Failing host/metric pairs
	// Read Only: true
	FailingHostLabelPairs []*SourceLabelPair `json:"failingHostLabelPairs"`

	// hidden
	// Read Only: true
	Hidden *bool `json:"hidden,omitempty"`

	// Number of hosts checked by the alert condition
	// Read Only: true
	HostsUsed []string `json:"hostsUsed"`

	// id
	ID string `json:"id,omitempty"`

	// Lists the sources that will not be checked for this alert, due to matching a maintenance window
	// Read Only: true
	InMaintenanceHostLabelPairs []*SourceLabelPair `json:"inMaintenanceHostLabelPairs"`

	// in trash
	InTrash bool `json:"inTrash,omitempty"`

	// Whether to include obsolete metrics in alert query
	IncludeObsoleteMetrics bool `json:"includeObsoleteMetrics,omitempty"`

	// The last error encountered when running this alert's condition query
	// Read Only: true
	LastErrorMessage string `json:"lastErrorMessage,omitempty"`

	// Start time (in epoch millis) of the last event associated with this alert.
	// Read Only: true
	LastEventTime int64 `json:"lastEventTime,omitempty"`

	// The time of the last error encountered when running this alert's condition query, in epoch millis
	// Read Only: true
	LastFailedTime int64 `json:"lastFailedTime,omitempty"`

	// When this alert last caused a notification, in epoch millis
	// Read Only: true
	LastNotificationMillis int64 `json:"lastNotificationMillis,omitempty"`

	// The time when this alert was last checked, in epoch millis
	// Read Only: true
	LastProcessedMillis int64 `json:"lastProcessedMillis,omitempty"`

	// Last query time of the alert, averaged on hourly basis
	// Read Only: true
	LastQueryTime int64 `json:"lastQueryTime,omitempty"`

	// Number of metrics checked by the alert condition
	// Read Only: true
	MetricsUsed []string `json:"metricsUsed"`

	// The number of consecutive minutes that a series matching the condition query must evaluate to "true" (non-zero value) before the alert fires
	// Required: true
	Minutes *int32 `json:"minutes"`

	// Whether the user has modify ACL access to the alert.
	ModifyACLAccess bool `json:"modifyAclAccess,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// No data event related to the alert
	// Read Only: true
	NoDataEvent *Event `json:"noDataEvent,omitempty"`

	// A derived field listing the webhook ids used by this alert
	// Read Only: true
	Notificants []string `json:"notificants"`

	// How often to re-trigger a continually failing alert. If absent or <= 0, no retriggering occurs
	NotificationResendFrequencyMinutes int64 `json:"notificationResendFrequencyMinutes,omitempty"`

	// Number of points scanned in alert query time frame.
	// Read Only: true
	NumPointsInFailureFrame int32 `json:"numPointsInFailureFrame,omitempty"`

	// orphan
	// Read Only: true
	Orphan *bool `json:"orphan,omitempty"`

	// A derived field recording the number of data points scanned when the system last computed this alert's condition
	// Read Only: true
	PointsScannedAtLastQuery int64 `json:"pointsScannedAtLastQuery,omitempty"`

	// Lists the series that are starting to fail, defined as failing for greater than 50% of the checks in the window determined by the "minutes" parameter
	// Read Only: true
	PrefiringHostLabelPairs []*SourceLabelPair `json:"prefiringHostLabelPairs"`

	// The interval between checks for this alert, in minutes.  Defaults to 1 minute
	ProcessRateMinutes int32 `json:"processRateMinutes,omitempty"`

	// Whether there was an exception when the alert condition last ran
	// Read Only: true
	QueryFailing *bool `json:"queryFailing,omitempty"`

	// Whether there was an query syntax exception when the alert condition last ran
	// Read Only: true
	QuerySyntaxError *bool `json:"querySyntaxError,omitempty"`

	// The number of consecutive minutes that a firing series matching the condition query must evaluate to "false" (zero value) before the alert resolves.  When unset, this defaults to the same value as "minutes"
	ResolveAfterMinutes int32 `json:"resolveAfterMinutes,omitempty"`

	// User-supplied runbook links for this alert. Useful for linking wiki page or documentation, etc to refer to when alert is triggered
	RunbookLinks []string `json:"runbookLinks"`

	// Whether to secure sensitive metric details and alert images in alert notifications, to not break Metrics Security.
	SecureMetricDetails bool `json:"secureMetricDetails,omitempty"`

	// Lists the services from the failingHostLabelPair of the alert.
	// Read Only: true
	Service []string `json:"service"`

	// Severity of the alert
	// Enum: [INFO SMOKE WARN SEVERE]
	Severity string `json:"severity,omitempty"`

	// Alert severity list for multi-threshold type.
	// Read Only: true
	SeverityList []string `json:"severityList"`

	// The until which time this alert is snoozed (not checked), in epoch millis.  A negative value implies the alert is snoozed indefinitely
	Snoozed int64 `json:"snoozed,omitempty"`

	// Attribute used for default alert sort that is derived from state and severity
	// Read Only: true
	SortAttr int32 `json:"sortAttr,omitempty"`

	// Lists the current state of the alert. Can be one or more of: FIRING,SNOOZED, IN_MAINTENANCE, INVALID, NONE, CHECKING, TRASH, NO_DATA
	// Read Only: true
	Status []string `json:"status"`

	// If this is a system alert, the version of it
	SystemAlertVersion int32 `json:"systemAlertVersion,omitempty"`

	// Whether this alert is system-owned and not writeable
	// Read Only: true
	SystemOwned *bool `json:"systemOwned,omitempty"`

	// tagpaths
	// Read Only: true
	Tagpaths []string `json:"tagpaths"`

	// tags
	Tags *WFTags `json:"tags,omitempty"`

	// The email address or integration endpoint (such as PagerDuty or web hook) to notify when the alert status changes. Comma-separated list of targets. Multiple target types can be in the list. Alert target format: ({email}|pd:{pd_key}|target:{alert target ID})
	Target string `json:"target,omitempty"`

	// target endpoints
	// Read Only: true
	TargetEndpoints []string `json:"targetEndpoints"`

	// List of alert targets display information that includes name, id and type.
	// Read Only: true
	TargetInfo []*TargetInfo `json:"targetInfo"`

	// Targets for severity.
	Targets map[string]string `json:"targets,omitempty"`

	// Deprecated for alertTriageDashboards
	TriageDashboards []*TriageDashboard `json:"triageDashboards"`

	// The user that last updated this alert
	// Read Only: true
	UpdateUserID string `json:"updateUserId,omitempty"`

	// When the alert was last updated, in epoch millis
	// Read Only: true
	Updated int64 `json:"updated,omitempty"`

	// updated epoch millis
	// Read Only: true
	UpdatedEpochMillis int64 `json:"updatedEpochMillis,omitempty"`

	// updater Id
	// Read Only: true
	UpdaterID string `json:"updaterId,omitempty"`
}

// Validate validates this alert
func (m *Alert) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateACL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertSources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertTriageDashboards(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChartSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditionQueryType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayExpressionQueryType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailingHostLabelPairLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailingHostLabelPairs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInMaintenanceHostLabelPairs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinutes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoDataEvent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrefiringHostLabelPairs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverityList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriageDashboards(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Alert) validateACL(formats strfmt.Registry) error {
	if swag.IsZero(m.ACL) { // not required
		return nil
	}

	if m.ACL != nil {
		if err := m.ACL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("acl")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) validateAlertSources(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertSources) { // not required
		return nil
	}

	for i := 0; i < len(m.AlertSources); i++ {
		if swag.IsZero(m.AlertSources[i]) { // not required
			continue
		}

		if m.AlertSources[i] != nil {
			if err := m.AlertSources[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("alertSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("alertSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) validateAlertTriageDashboards(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertTriageDashboards) { // not required
		return nil
	}

	for i := 0; i < len(m.AlertTriageDashboards); i++ {
		if swag.IsZero(m.AlertTriageDashboards[i]) { // not required
			continue
		}

		if m.AlertTriageDashboards[i] != nil {
			if err := m.AlertTriageDashboards[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("alertTriageDashboards" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("alertTriageDashboards" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var alertTypeAlertTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CLASSIC","THRESHOLD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeAlertTypePropEnum = append(alertTypeAlertTypePropEnum, v)
	}
}

const (

	// AlertAlertTypeCLASSIC captures enum value "CLASSIC"
	AlertAlertTypeCLASSIC string = "CLASSIC"

	// AlertAlertTypeTHRESHOLD captures enum value "THRESHOLD"
	AlertAlertTypeTHRESHOLD string = "THRESHOLD"
)

// prop value enum
func (m *Alert) validateAlertTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeAlertTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateAlertType(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertTypeEnum("alertType", "body", m.AlertType); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateChartSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.ChartSettings) { // not required
		return nil
	}

	if m.ChartSettings != nil {
		if err := m.ChartSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("chartSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("chartSettings")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) validateCondition(formats strfmt.Registry) error {

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	return nil
}

var alertTypeConditionQueryTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["WQL","PROMQL","HYBRID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeConditionQueryTypePropEnum = append(alertTypeConditionQueryTypePropEnum, v)
	}
}

const (

	// AlertConditionQueryTypeWQL captures enum value "WQL"
	AlertConditionQueryTypeWQL string = "WQL"

	// AlertConditionQueryTypePROMQL captures enum value "PROMQL"
	AlertConditionQueryTypePROMQL string = "PROMQL"

	// AlertConditionQueryTypeHYBRID captures enum value "HYBRID"
	AlertConditionQueryTypeHYBRID string = "HYBRID"
)

// prop value enum
func (m *Alert) validateConditionQueryTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeConditionQueryTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateConditionQueryType(formats strfmt.Registry) error {
	if swag.IsZero(m.ConditionQueryType) { // not required
		return nil
	}

	// value enum
	if err := m.validateConditionQueryTypeEnum("conditionQueryType", "body", m.ConditionQueryType); err != nil {
		return err
	}

	return nil
}

var alertTypeDisplayExpressionQueryTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["WQL","PROMQL","HYBRID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeDisplayExpressionQueryTypePropEnum = append(alertTypeDisplayExpressionQueryTypePropEnum, v)
	}
}

const (

	// AlertDisplayExpressionQueryTypeWQL captures enum value "WQL"
	AlertDisplayExpressionQueryTypeWQL string = "WQL"

	// AlertDisplayExpressionQueryTypePROMQL captures enum value "PROMQL"
	AlertDisplayExpressionQueryTypePROMQL string = "PROMQL"

	// AlertDisplayExpressionQueryTypeHYBRID captures enum value "HYBRID"
	AlertDisplayExpressionQueryTypeHYBRID string = "HYBRID"
)

// prop value enum
func (m *Alert) validateDisplayExpressionQueryTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeDisplayExpressionQueryTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateDisplayExpressionQueryType(formats strfmt.Registry) error {
	if swag.IsZero(m.DisplayExpressionQueryType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDisplayExpressionQueryTypeEnum("displayExpressionQueryType", "body", m.DisplayExpressionQueryType); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateEvent(formats strfmt.Registry) error {
	if swag.IsZero(m.Event) { // not required
		return nil
	}

	if m.Event != nil {
		if err := m.Event.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("event")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("event")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) validateFailingHostLabelPairLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.FailingHostLabelPairLinks) { // not required
		return nil
	}

	if err := validate.UniqueItems("failingHostLabelPairLinks", "body", m.FailingHostLabelPairLinks); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateFailingHostLabelPairs(formats strfmt.Registry) error {
	if swag.IsZero(m.FailingHostLabelPairs) { // not required
		return nil
	}

	for i := 0; i < len(m.FailingHostLabelPairs); i++ {
		if swag.IsZero(m.FailingHostLabelPairs[i]) { // not required
			continue
		}

		if m.FailingHostLabelPairs[i] != nil {
			if err := m.FailingHostLabelPairs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("failingHostLabelPairs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("failingHostLabelPairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) validateInMaintenanceHostLabelPairs(formats strfmt.Registry) error {
	if swag.IsZero(m.InMaintenanceHostLabelPairs) { // not required
		return nil
	}

	for i := 0; i < len(m.InMaintenanceHostLabelPairs); i++ {
		if swag.IsZero(m.InMaintenanceHostLabelPairs[i]) { // not required
			continue
		}

		if m.InMaintenanceHostLabelPairs[i] != nil {
			if err := m.InMaintenanceHostLabelPairs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inMaintenanceHostLabelPairs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inMaintenanceHostLabelPairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) validateMinutes(formats strfmt.Registry) error {

	if err := validate.Required("minutes", "body", m.Minutes); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateNoDataEvent(formats strfmt.Registry) error {
	if swag.IsZero(m.NoDataEvent) { // not required
		return nil
	}

	if m.NoDataEvent != nil {
		if err := m.NoDataEvent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("noDataEvent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("noDataEvent")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) validatePrefiringHostLabelPairs(formats strfmt.Registry) error {
	if swag.IsZero(m.PrefiringHostLabelPairs) { // not required
		return nil
	}

	for i := 0; i < len(m.PrefiringHostLabelPairs); i++ {
		if swag.IsZero(m.PrefiringHostLabelPairs[i]) { // not required
			continue
		}

		if m.PrefiringHostLabelPairs[i] != nil {
			if err := m.PrefiringHostLabelPairs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("prefiringHostLabelPairs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("prefiringHostLabelPairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var alertTypeSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INFO","SMOKE","WARN","SEVERE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeSeverityPropEnum = append(alertTypeSeverityPropEnum, v)
	}
}

const (

	// AlertSeverityINFO captures enum value "INFO"
	AlertSeverityINFO string = "INFO"

	// AlertSeveritySMOKE captures enum value "SMOKE"
	AlertSeveritySMOKE string = "SMOKE"

	// AlertSeverityWARN captures enum value "WARN"
	AlertSeverityWARN string = "WARN"

	// AlertSeveritySEVERE captures enum value "SEVERE"
	AlertSeveritySEVERE string = "SEVERE"
)

// prop value enum
func (m *Alert) validateSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateSeverity(formats strfmt.Registry) error {
	if swag.IsZero(m.Severity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

var alertSeverityListItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INFO","SMOKE","WARN","SEVERE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertSeverityListItemsEnum = append(alertSeverityListItemsEnum, v)
	}
}

func (m *Alert) validateSeverityListItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertSeverityListItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateSeverityList(formats strfmt.Registry) error {
	if swag.IsZero(m.SeverityList) { // not required
		return nil
	}

	for i := 0; i < len(m.SeverityList); i++ {

		// value enum
		if err := m.validateSeverityListItemsEnum("severityList"+"."+strconv.Itoa(i), "body", m.SeverityList[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *Alert) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	if m.Tags != nil {
		if err := m.Tags.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tags")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tags")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) validateTargetInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetInfo) { // not required
		return nil
	}

	for i := 0; i < len(m.TargetInfo); i++ {
		if swag.IsZero(m.TargetInfo[i]) { // not required
			continue
		}

		if m.TargetInfo[i] != nil {
			if err := m.TargetInfo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targetInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targetInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) validateTriageDashboards(formats strfmt.Registry) error {
	if swag.IsZero(m.TriageDashboards) { // not required
		return nil
	}

	for i := 0; i < len(m.TriageDashboards); i++ {
		if swag.IsZero(m.TriageDashboards[i]) { // not required
			continue
		}

		if m.TriageDashboards[i] != nil {
			if err := m.TriageDashboards[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("triageDashboards" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("triageDashboards" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this alert based on the context it is used
func (m *Alert) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateACL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateActiveMaintenanceWindows(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertSources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertTriageDashboards(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertsLastDay(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertsLastMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertsLastWeek(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateApplication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChartSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedEpochMillis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatorID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeleted(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEvent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailingHostLabelPairLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailingHostLabelPairs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHidden(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostsUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInMaintenanceHostLabelPairs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastErrorMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastEventTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastFailedTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastNotificationMillis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastProcessedMillis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastQueryTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetricsUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNoDataEvent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotificants(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNumPointsInFailureFrame(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrphan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePointsScannedAtLastQuery(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrefiringHostLabelPairs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryFailing(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuerySyntaxError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSeverityList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSortAttr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemOwned(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTagpaths(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetEndpoints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTriageDashboards(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdateUserID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedEpochMillis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdaterID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Alert) contextValidateACL(ctx context.Context, formats strfmt.Registry) error {

	if m.ACL != nil {
		if err := m.ACL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("acl")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) contextValidateActiveMaintenanceWindows(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "activeMaintenanceWindows", "body", []string(m.ActiveMaintenanceWindows)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateAlertSources(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AlertSources); i++ {

		if m.AlertSources[i] != nil {
			if err := m.AlertSources[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("alertSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("alertSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateAlertTriageDashboards(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AlertTriageDashboards); i++ {

		if m.AlertTriageDashboards[i] != nil {
			if err := m.AlertTriageDashboards[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("alertTriageDashboards" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("alertTriageDashboards" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateAlertsLastDay(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertsLastDay", "body", int32(m.AlertsLastDay)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateAlertsLastMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertsLastMonth", "body", int32(m.AlertsLastMonth)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateAlertsLastWeek(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertsLastWeek", "body", int32(m.AlertsLastWeek)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateApplication(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "application", "body", []string(m.Application)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateChartSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.ChartSettings != nil {
		if err := m.ChartSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("chartSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("chartSettings")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) contextValidateCreateUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createUserId", "body", string(m.CreateUserID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateCreated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "created", "body", int64(m.Created)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateCreatedEpochMillis(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdEpochMillis", "body", int64(m.CreatedEpochMillis)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateCreatorID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "creatorId", "body", string(m.CreatorID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateDeleted(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "deleted", "body", m.Deleted); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateEvent(ctx context.Context, formats strfmt.Registry) error {

	if m.Event != nil {
		if err := m.Event.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("event")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("event")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) contextValidateFailingHostLabelPairLinks(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "failingHostLabelPairLinks", "body", []string(m.FailingHostLabelPairLinks)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateFailingHostLabelPairs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "failingHostLabelPairs", "body", []*SourceLabelPair(m.FailingHostLabelPairs)); err != nil {
		return err
	}

	for i := 0; i < len(m.FailingHostLabelPairs); i++ {

		if m.FailingHostLabelPairs[i] != nil {
			if err := m.FailingHostLabelPairs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("failingHostLabelPairs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("failingHostLabelPairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateHidden(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "hidden", "body", m.Hidden); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateHostsUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "hostsUsed", "body", []string(m.HostsUsed)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateInMaintenanceHostLabelPairs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "inMaintenanceHostLabelPairs", "body", []*SourceLabelPair(m.InMaintenanceHostLabelPairs)); err != nil {
		return err
	}

	for i := 0; i < len(m.InMaintenanceHostLabelPairs); i++ {

		if m.InMaintenanceHostLabelPairs[i] != nil {
			if err := m.InMaintenanceHostLabelPairs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inMaintenanceHostLabelPairs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inMaintenanceHostLabelPairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateLastErrorMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastErrorMessage", "body", string(m.LastErrorMessage)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateLastEventTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastEventTime", "body", int64(m.LastEventTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateLastFailedTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastFailedTime", "body", int64(m.LastFailedTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateLastNotificationMillis(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastNotificationMillis", "body", int64(m.LastNotificationMillis)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateLastProcessedMillis(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastProcessedMillis", "body", int64(m.LastProcessedMillis)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateLastQueryTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastQueryTime", "body", int64(m.LastQueryTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateMetricsUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metricsUsed", "body", []string(m.MetricsUsed)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateNoDataEvent(ctx context.Context, formats strfmt.Registry) error {

	if m.NoDataEvent != nil {
		if err := m.NoDataEvent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("noDataEvent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("noDataEvent")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) contextValidateNotificants(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "notificants", "body", []string(m.Notificants)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateNumPointsInFailureFrame(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "numPointsInFailureFrame", "body", int32(m.NumPointsInFailureFrame)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateOrphan(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "orphan", "body", m.Orphan); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidatePointsScannedAtLastQuery(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "pointsScannedAtLastQuery", "body", int64(m.PointsScannedAtLastQuery)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidatePrefiringHostLabelPairs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "prefiringHostLabelPairs", "body", []*SourceLabelPair(m.PrefiringHostLabelPairs)); err != nil {
		return err
	}

	for i := 0; i < len(m.PrefiringHostLabelPairs); i++ {

		if m.PrefiringHostLabelPairs[i] != nil {
			if err := m.PrefiringHostLabelPairs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("prefiringHostLabelPairs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("prefiringHostLabelPairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateQueryFailing(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "queryFailing", "body", m.QueryFailing); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateQuerySyntaxError(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "querySyntaxError", "body", m.QuerySyntaxError); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateService(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service", "body", []string(m.Service)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateSeverityList(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "severityList", "body", []string(m.SeverityList)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateSortAttr(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sortAttr", "body", int32(m.SortAttr)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", []string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateSystemOwned(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "systemOwned", "body", m.SystemOwned); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateTagpaths(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tagpaths", "body", []string(m.Tagpaths)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	if m.Tags != nil {
		if err := m.Tags.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tags")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tags")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) contextValidateTargetEndpoints(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetEndpoints", "body", []string(m.TargetEndpoints)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateTargetInfo(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetInfo", "body", []*TargetInfo(m.TargetInfo)); err != nil {
		return err
	}

	for i := 0; i < len(m.TargetInfo); i++ {

		if m.TargetInfo[i] != nil {
			if err := m.TargetInfo[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targetInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targetInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateTriageDashboards(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TriageDashboards); i++ {

		if m.TriageDashboards[i] != nil {
			if err := m.TriageDashboards[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("triageDashboards" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("triageDashboards" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateUpdateUserID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updateUserId", "body", string(m.UpdateUserID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateUpdated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updated", "body", int64(m.Updated)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateUpdatedEpochMillis(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updatedEpochMillis", "body", int64(m.UpdatedEpochMillis)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateUpdaterID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updaterId", "body", string(m.UpdaterID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Alert) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Alert) UnmarshalBinary(b []byte) error {
	var res Alert
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
