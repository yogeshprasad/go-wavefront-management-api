// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Notificant Wavefront notificant entity
//
// swagger:model Notificant
type Notificant struct {

	// The value of the Content-Type header of the webhook POST request.
	// Enum: [application/json text/html text/plain application/x-www-form-urlencoded ]
	ContentType string `json:"contentType,omitempty"`

	// created epoch millis
	// Read Only: true
	CreatedEpochMillis int64 `json:"createdEpochMillis,omitempty"`

	// creator Id
	// Read Only: true
	CreatorID string `json:"creatorId,omitempty"`

	// A string->string map specifying the custom HTTP header key / value pairs that will be sent in the requests of this web hook
	CustomHTTPHeaders map[string]string `json:"customHttpHeaders,omitempty"`

	// customer Id
	// Read Only: true
	CustomerID string `json:"customerId,omitempty"`

	// Description
	// Required: true
	Description *string `json:"description"`

	// The subject title of an email notification target
	EmailSubject string `json:"emailSubject,omitempty"`

	// id
	ID string `json:"id,omitempty"`

	// Determine whether the email alert target content is sent as html or text.
	IsHTMLContent bool `json:"isHtmlContent,omitempty"`

	// The notification method used for notification target.
	// Required: true
	// Enum: [WEBHOOK EMAIL PAGERDUTY]
	Method *string `json:"method"`

	// The end point for the notification target.EMAIL: email address.  PAGERDUTY: PagerDuty routing Key.  WEBHOOK: URL end point
	// Required: true
	Recipient *string `json:"recipient"`

	// List of routing targets that this notificant will notify.
	Routes []*AlertRoute `json:"routes"`

	// A mustache template that will form the body of the POST request, email and summary of the PagerDuty.
	// Required: true
	Template *string `json:"template"`

	// Title
	// Required: true
	Title *string `json:"title"`

	// A list of occurrences on which this webhook will be fired.  Valid values are ALERT_OPENED, ALERT_UPDATED, ALERT_RESOLVED, ALERT_MAINTENANCE, ALERT_SNOOZED
	// Required: true
	Triggers []string `json:"triggers"`

	// updated epoch millis
	// Read Only: true
	UpdatedEpochMillis int64 `json:"updatedEpochMillis,omitempty"`

	// updater Id
	// Read Only: true
	UpdaterID string `json:"updaterId,omitempty"`
}

// Validate validates this notificant
func (m *Notificant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTemplate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var notificantTypeContentTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["application/json","text/html","text/plain","application/x-www-form-urlencoded",""]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		notificantTypeContentTypePropEnum = append(notificantTypeContentTypePropEnum, v)
	}
}

const (

	// NotificantContentTypeApplicationJSON captures enum value "application/json"
	NotificantContentTypeApplicationJSON string = "application/json"

	// NotificantContentTypeTextHTML captures enum value "text/html"
	NotificantContentTypeTextHTML string = "text/html"

	// NotificantContentTypeTextPlain captures enum value "text/plain"
	NotificantContentTypeTextPlain string = "text/plain"

	// NotificantContentTypeApplicationxDashWwwDashFormDashUrlencoded captures enum value "application/x-www-form-urlencoded"
	NotificantContentTypeApplicationxDashWwwDashFormDashUrlencoded string = "application/x-www-form-urlencoded"

	// NotificantContentTypeEmpty captures enum value ""
	NotificantContentTypeEmpty string = ""
)

// prop value enum
func (m *Notificant) validateContentTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, notificantTypeContentTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Notificant) validateContentType(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentType) { // not required
		return nil
	}

	// value enum
	if err := m.validateContentTypeEnum("contentType", "body", m.ContentType); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

var notificantTypeMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["WEBHOOK","EMAIL","PAGERDUTY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		notificantTypeMethodPropEnum = append(notificantTypeMethodPropEnum, v)
	}
}

const (

	// NotificantMethodWEBHOOK captures enum value "WEBHOOK"
	NotificantMethodWEBHOOK string = "WEBHOOK"

	// NotificantMethodEMAIL captures enum value "EMAIL"
	NotificantMethodEMAIL string = "EMAIL"

	// NotificantMethodPAGERDUTY captures enum value "PAGERDUTY"
	NotificantMethodPAGERDUTY string = "PAGERDUTY"
)

// prop value enum
func (m *Notificant) validateMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, notificantTypeMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Notificant) validateMethod(formats strfmt.Registry) error {

	if err := validate.Required("method", "body", m.Method); err != nil {
		return err
	}

	// value enum
	if err := m.validateMethodEnum("method", "body", *m.Method); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) validateRecipient(formats strfmt.Registry) error {

	if err := validate.Required("recipient", "body", m.Recipient); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) validateRoutes(formats strfmt.Registry) error {
	if swag.IsZero(m.Routes) { // not required
		return nil
	}

	for i := 0; i < len(m.Routes); i++ {
		if swag.IsZero(m.Routes[i]) { // not required
			continue
		}

		if m.Routes[i] != nil {
			if err := m.Routes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("routes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("routes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Notificant) validateTemplate(formats strfmt.Registry) error {

	if err := validate.Required("template", "body", m.Template); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) validateTitle(formats strfmt.Registry) error {

	if err := validate.Required("title", "body", m.Title); err != nil {
		return err
	}

	return nil
}

var notificantTriggersItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ALERT_OPENED","ALERT_UPDATED","ALERT_RESOLVED","ALERT_MAINTENANCE","ALERT_SNOOZED","ALERT_INVALID","ALERT_NO_LONGER_INVALID","ALERT_TESTING","ALERT_RETRIGGERED","ALERT_NO_DATA","ALERT_NO_DATA_RESOLVED","ALERT_NO_DATA_MAINTENANCE","ALERT_SEVERITY_UPDATE","ALERT_NOTIFICATION_PREVIEW"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		notificantTriggersItemsEnum = append(notificantTriggersItemsEnum, v)
	}
}

func (m *Notificant) validateTriggersItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, notificantTriggersItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Notificant) validateTriggers(formats strfmt.Registry) error {

	if err := validate.Required("triggers", "body", m.Triggers); err != nil {
		return err
	}

	for i := 0; i < len(m.Triggers); i++ {

		// value enum
		if err := m.validateTriggersItemsEnum("triggers"+"."+strconv.Itoa(i), "body", m.Triggers[i]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validate this notificant based on the context it is used
func (m *Notificant) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreatedEpochMillis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatorID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomerID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRoutes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedEpochMillis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdaterID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Notificant) contextValidateCreatedEpochMillis(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdEpochMillis", "body", int64(m.CreatedEpochMillis)); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) contextValidateCreatorID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "creatorId", "body", string(m.CreatorID)); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) contextValidateCustomerID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "customerId", "body", string(m.CustomerID)); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) contextValidateRoutes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Routes); i++ {

		if m.Routes[i] != nil {
			if err := m.Routes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("routes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("routes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Notificant) contextValidateUpdatedEpochMillis(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updatedEpochMillis", "body", int64(m.UpdatedEpochMillis)); err != nil {
		return err
	}

	return nil
}

func (m *Notificant) contextValidateUpdaterID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updaterId", "body", string(m.UpdaterID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Notificant) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Notificant) UnmarshalBinary(b []byte) error {
	var res Notificant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
