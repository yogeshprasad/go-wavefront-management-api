// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IngestionPolicyReadModel Api model for ingestion policy
//
// swagger:model IngestionPolicyReadModel
type IngestionPolicyReadModel struct {

	// Total number of accounts that are linked to the ingestion policy
	// Read Only: true
	AccountCount int32 `json:"accountCount,omitempty"`

	// The accounts associated with the ingestion policy
	Accounts []*AccessControlElement `json:"accounts"`

	// The ingestion policy alert Id
	AlertID string `json:"alertId,omitempty"`

	// ID of the customer to which the ingestion policy belongs
	Customer string `json:"customer,omitempty"`

	// The description of the ingestion policy
	Description string `json:"description,omitempty"`

	// Total number of groups that are linked to the ingestion policy
	// Read Only: true
	GroupCount int32 `json:"groupCount,omitempty"`

	// The groups associated with the ingestion policy
	Groups []*AccessControlElement `json:"groups"`

	// The unique ID for the ingestion policy
	ID string `json:"id,omitempty"`

	// Whether the ingestion policy is limited
	IsLimited bool `json:"isLimited,omitempty"`

	// The account that updated this ingestion policy last time
	// Read Only: true
	LastUpdatedAccountID string `json:"lastUpdatedAccountId,omitempty"`

	// The last time when the ingestion policy is updated, in epoch milliseconds
	LastUpdatedMs int64 `json:"lastUpdatedMs,omitempty"`

	// The PPS limit of the ingestion policy
	LimitPPS int32 `json:"limitPPS,omitempty"`

	// metadata associated with the ingestion policy
	Metadata *IngestionPolicyMetadata `json:"metadata,omitempty"`

	// The name of the ingestion policy
	Name string `json:"name,omitempty"`

	// The namespaces associated with the ingestion policy
	Namespaces []string `json:"namespaces"`

	// The point tags associated with the ingestion policy
	PointTags []*Annotation `json:"pointTags"`

	// A sample of the accounts assigned to this ingestion policy. Please use the Ingestion Policy facet of the Account Search API to get the full list of accounts for this policy
	// Read Only: true
	// Unique: true
	SampledAccounts []string `json:"sampledAccounts"`

	// A sample of the groups assigned to this ingestion policy. Please use the Ingestion Policy facet of the Group Search API to get the full list of groups for this policy
	// Read Only: true
	// Unique: true
	SampledGroups []*UserGroup `json:"sampledGroups"`

	// A sample of the service accounts accounts assigned to this ingestion policy. Please use the Ingestion Policy facet of the Account Search API to get the full list of service accounts for this policy
	// Read Only: true
	// Unique: true
	SampledServiceAccounts []string `json:"sampledServiceAccounts"`

	// A sample of the user accounts assigned to this ingestion policy. Please use the Ingestion Policy facet of the Account Search API to get the full list of users for this policy
	// Read Only: true
	// Unique: true
	SampledUserAccounts []string `json:"sampledUserAccounts"`

	// The scope of the ingestion policy
	// Enum: [ACCOUNT GROUP NAMESPACE SOURCE TAGS]
	Scope string `json:"scope,omitempty"`

	// Total number of service accounts that are linked to the ingestion policy
	// Read Only: true
	ServiceAccountCount int32 `json:"serviceAccountCount,omitempty"`

	// The sources associated with the ingestion policy
	Sources []string `json:"sources"`

	// Whether tags should be AND-ed or OR-ed.If true, a metric must contain all tags in order for the ingestion policy to apply. If false, the tags are OR-ed, and a metric must contain one of the tags. Default: false
	TagsAnded bool `json:"tagsAnded,omitempty"`

	// Total number of user accounts that are linked to the ingestion policy
	// Read Only: true
	UserAccountCount int32 `json:"userAccountCount,omitempty"`
}

// Validate validates this ingestion policy read model
func (m *IngestionPolicyReadModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePointTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSampledAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSampledGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSampledServiceAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSampledUserAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IngestionPolicyReadModel) validateAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.Accounts) { // not required
		return nil
	}

	for i := 0; i < len(m.Accounts); i++ {
		if swag.IsZero(m.Accounts[i]) { // not required
			continue
		}

		if m.Accounts[i] != nil {
			if err := m.Accounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("accounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("accounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) validateGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.Groups) { // not required
		return nil
	}

	for i := 0; i < len(m.Groups); i++ {
		if swag.IsZero(m.Groups[i]) { // not required
			continue
		}

		if m.Groups[i] != nil {
			if err := m.Groups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *IngestionPolicyReadModel) validatePointTags(formats strfmt.Registry) error {
	if swag.IsZero(m.PointTags) { // not required
		return nil
	}

	for i := 0; i < len(m.PointTags); i++ {
		if swag.IsZero(m.PointTags[i]) { // not required
			continue
		}

		if m.PointTags[i] != nil {
			if err := m.PointTags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pointTags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pointTags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) validateSampledAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledAccounts) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledAccounts", "body", m.SampledAccounts); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) validateSampledGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledGroups) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledGroups", "body", m.SampledGroups); err != nil {
		return err
	}

	for i := 0; i < len(m.SampledGroups); i++ {
		if swag.IsZero(m.SampledGroups[i]) { // not required
			continue
		}

		if m.SampledGroups[i] != nil {
			if err := m.SampledGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) validateSampledServiceAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledServiceAccounts) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledServiceAccounts", "body", m.SampledServiceAccounts); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) validateSampledUserAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.SampledUserAccounts) { // not required
		return nil
	}

	if err := validate.UniqueItems("sampledUserAccounts", "body", m.SampledUserAccounts); err != nil {
		return err
	}

	return nil
}

var ingestionPolicyReadModelTypeScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACCOUNT","GROUP","NAMESPACE","SOURCE","TAGS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ingestionPolicyReadModelTypeScopePropEnum = append(ingestionPolicyReadModelTypeScopePropEnum, v)
	}
}

const (

	// IngestionPolicyReadModelScopeACCOUNT captures enum value "ACCOUNT"
	IngestionPolicyReadModelScopeACCOUNT string = "ACCOUNT"

	// IngestionPolicyReadModelScopeGROUP captures enum value "GROUP"
	IngestionPolicyReadModelScopeGROUP string = "GROUP"

	// IngestionPolicyReadModelScopeNAMESPACE captures enum value "NAMESPACE"
	IngestionPolicyReadModelScopeNAMESPACE string = "NAMESPACE"

	// IngestionPolicyReadModelScopeSOURCE captures enum value "SOURCE"
	IngestionPolicyReadModelScopeSOURCE string = "SOURCE"

	// IngestionPolicyReadModelScopeTAGS captures enum value "TAGS"
	IngestionPolicyReadModelScopeTAGS string = "TAGS"
)

// prop value enum
func (m *IngestionPolicyReadModel) validateScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ingestionPolicyReadModelTypeScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IngestionPolicyReadModel) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	// value enum
	if err := m.validateScopeEnum("scope", "body", m.Scope); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this ingestion policy read model based on the context it is used
func (m *IngestionPolicyReadModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccountCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroupCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdatedAccountID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePointTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledServiceAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSampledUserAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceAccountCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserAccountCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IngestionPolicyReadModel) contextValidateAccountCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "accountCount", "body", int32(m.AccountCount)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateAccounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Accounts); i++ {

		if m.Accounts[i] != nil {
			if err := m.Accounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("accounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("accounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateGroupCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "groupCount", "body", int32(m.GroupCount)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Groups); i++ {

		if m.Groups[i] != nil {
			if err := m.Groups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateLastUpdatedAccountID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastUpdatedAccountId", "body", string(m.LastUpdatedAccountID)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {
		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidatePointTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PointTags); i++ {

		if m.PointTags[i] != nil {
			if err := m.PointTags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pointTags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pointTags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateSampledAccounts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledAccounts", "body", []string(m.SampledAccounts)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateSampledGroups(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledGroups", "body", []*UserGroup(m.SampledGroups)); err != nil {
		return err
	}

	for i := 0; i < len(m.SampledGroups); i++ {

		if m.SampledGroups[i] != nil {
			if err := m.SampledGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sampledGroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateSampledServiceAccounts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledServiceAccounts", "body", []string(m.SampledServiceAccounts)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateSampledUserAccounts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sampledUserAccounts", "body", []string(m.SampledUserAccounts)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateServiceAccountCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serviceAccountCount", "body", int32(m.ServiceAccountCount)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyReadModel) contextValidateUserAccountCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "userAccountCount", "body", int32(m.UserAccountCount)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IngestionPolicyReadModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IngestionPolicyReadModel) UnmarshalBinary(b []byte) error {
	var res IngestionPolicyReadModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
