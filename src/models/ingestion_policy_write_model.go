// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IngestionPolicyWriteModel Api model for ingestion policy
//
// swagger:model IngestionPolicyWriteModel
type IngestionPolicyWriteModel struct {

	// The accounts associated with the ingestion policy
	Accounts []string `json:"accounts"`

	// The ingestion policy alert Id
	AlertID string `json:"alertId,omitempty"`

	// ID of the customer to which the ingestion policy belongs
	Customer string `json:"customer,omitempty"`

	// The description of the ingestion policy
	Description string `json:"description,omitempty"`

	// The groups associated with the ingestion policy
	Groups []string `json:"groups"`

	// The unique ID for the ingestion policy
	ID string `json:"id,omitempty"`

	// Whether the ingestion policy is limited
	IsLimited bool `json:"isLimited,omitempty"`

	// The account that updated this ingestion policy last time
	// Read Only: true
	LastUpdatedAccountID string `json:"lastUpdatedAccountId,omitempty"`

	// The last time when the ingestion policy is updated, in epoch milliseconds
	LastUpdatedMs int64 `json:"lastUpdatedMs,omitempty"`

	// The PPS limit of the ingestion policy
	LimitPPS int32 `json:"limitPPS,omitempty"`

	// The name of the ingestion policy
	Name string `json:"name,omitempty"`

	// The namespaces associated with the ingestion policy
	Namespaces []string `json:"namespaces"`

	// The point tags associated with the ingestion policy
	PointTags []*Annotation `json:"pointTags"`

	// The scope of the ingestion policy
	// Enum: [ACCOUNT GROUP NAMESPACE SOURCE TAGS]
	Scope string `json:"scope,omitempty"`

	// The sources associated with the ingestion policy
	Sources []string `json:"sources"`

	// Whether tags should be AND-ed or OR-ed.If true, a metric must contain all tags in order for the ingestion policy to apply. If false, the tags are OR-ed, and a metric must contain one of the tags. Default: false
	TagsAnded bool `json:"tagsAnded,omitempty"`
}

// Validate validates this ingestion policy write model
func (m *IngestionPolicyWriteModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePointTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IngestionPolicyWriteModel) validatePointTags(formats strfmt.Registry) error {
	if swag.IsZero(m.PointTags) { // not required
		return nil
	}

	for i := 0; i < len(m.PointTags); i++ {
		if swag.IsZero(m.PointTags[i]) { // not required
			continue
		}

		if m.PointTags[i] != nil {
			if err := m.PointTags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pointTags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pointTags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var ingestionPolicyWriteModelTypeScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACCOUNT","GROUP","NAMESPACE","SOURCE","TAGS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ingestionPolicyWriteModelTypeScopePropEnum = append(ingestionPolicyWriteModelTypeScopePropEnum, v)
	}
}

const (

	// IngestionPolicyWriteModelScopeACCOUNT captures enum value "ACCOUNT"
	IngestionPolicyWriteModelScopeACCOUNT string = "ACCOUNT"

	// IngestionPolicyWriteModelScopeGROUP captures enum value "GROUP"
	IngestionPolicyWriteModelScopeGROUP string = "GROUP"

	// IngestionPolicyWriteModelScopeNAMESPACE captures enum value "NAMESPACE"
	IngestionPolicyWriteModelScopeNAMESPACE string = "NAMESPACE"

	// IngestionPolicyWriteModelScopeSOURCE captures enum value "SOURCE"
	IngestionPolicyWriteModelScopeSOURCE string = "SOURCE"

	// IngestionPolicyWriteModelScopeTAGS captures enum value "TAGS"
	IngestionPolicyWriteModelScopeTAGS string = "TAGS"
)

// prop value enum
func (m *IngestionPolicyWriteModel) validateScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ingestionPolicyWriteModelTypeScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IngestionPolicyWriteModel) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	// value enum
	if err := m.validateScopeEnum("scope", "body", m.Scope); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this ingestion policy write model based on the context it is used
func (m *IngestionPolicyWriteModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastUpdatedAccountID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePointTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IngestionPolicyWriteModel) contextValidateLastUpdatedAccountID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastUpdatedAccountId", "body", string(m.LastUpdatedAccountID)); err != nil {
		return err
	}

	return nil
}

func (m *IngestionPolicyWriteModel) contextValidatePointTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PointTags); i++ {

		if m.PointTags[i] != nil {
			if err := m.PointTags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pointTags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pointTags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *IngestionPolicyWriteModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IngestionPolicyWriteModel) UnmarshalBinary(b []byte) error {
	var res IngestionPolicyWriteModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
